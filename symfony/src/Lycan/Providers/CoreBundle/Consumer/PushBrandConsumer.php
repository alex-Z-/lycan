<?php

namespace Lycan\Providers\CoreBundle\Consumer;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\PersistentCollection;
use Lycan\Providers\CoreBundle\API\ManagerInterface;
use OldSound\RabbitMqBundle\RabbitMq\ConsumerInterface;
use PhpAmqpLib\Message\AMQPMessage;
use Ramsey\Uuid\Uuid;
use React\Promise\Deferred;
class PushBrandConsumer implements ConsumerInterface
{
	
	
	
	private $logger; // Monolog-logger.
	private $container;
	private $em;
	// Init:
	public function __construct( $logger, $em )
	{
		$this->logger = $logger->logger;
		$this->em = $em;
		echo "PushBrand is listening...";
	}
	
	public function setContainer($container){
		$this->container = $container;
	}
	
	public function execute(AMQPMessage $msg)
	{
		
		$message = unserialize($msg->body);
		$id = $message['id'];
		
		$batchLogger = $this->container->get('app.logger.jobs');
		$batchLogger->setBatch($message['batch']);
		$batchLogger->setEventGroup( Uuid::uuid4() );
		$batchLogger->info("Processing Push Brand", $message);
		
		
		$channel = $this->em->getRepository('AppBundle:ChannelBrand')->find($id);
		if(!$channel){
			$batchLogger->crit("Channel does not exist.", $message );
			// Discard the message.
			return true;
		}
		if(!$channel->getPushInProgress() ){
			$batchLogger->warning("Channel is not recognised as in progress. Terminating Push Request.", $message );
			// Discard the message.
			return true;
		}
		
		// Get the provider information from the channel.
		// Get all properties on the brand
		// Create a push_listing job for each property to push it to the provider
		$provider = $channel->getProvider();
		$providerKey = strtolower( $provider->getProviderName() );
		/* @var ManagerInterface */
		$manager = $this->container->get('lycan.provider.manager.factory')->create($providerKey);
		// This is the BATCH that all messages generated by this manager will be associated with.
		$manager->setBatch( $this->em->getReference("CoreBundle:BatchExecutions", $message['batch']));
		$manager->setProvider($provider);
		
		// This is the associatedd BRAND.
		$brand = $channel->getBrand();
		// We have to make sure that ALL listings have been created that should be pushed.
		
		$properties = $this->em->getRepository("AppBundle:Property")->findMissingChannelBrandListings($channel);
		
		if($properties){
			foreach($properties as $property){
				// Create the listing.
				$channelListing = new Listing();
				$channelListing->setChannel($channel);
				$channelListing->setProvider($channel->getProvider());
				$channelListing->setSchemaObject($property->getSchemaObject());
				$channelListing->setMaster($property);
				$channelListing->setDescriptiveName($property->getDescriptiveName());
				// TODO - How can you use the parent?
				$channelListing->setIsSchemaValid($property->getIsSchemaValid());
				$channelListing->setArePoliciesValid(false);
				
				$this->em->persist($channelListing);
				$this->em->persist($property);
			}
			$this->em->flush();
		}
		
		// Now we need to get all listings on a brand.
		// THESE ARE LISTINGS -> NOT Properties.
		$listings = $channel->getListings();
		$partitionChunkSize = 250;
		
		
		if($listings->count() > 0){
			
			// We have to BREAK up the listings into Batches. Unfortunately, Anything more than abotu 1000 listings causes
			// memory issues. So, iof the brand is less than 500 listings, fine, process it, but if it's more, send it back
			// To RabbitMQ to split the job into smaller jobs.
			if($listings->count() > 500 && !isset($message['partitionIndex'])){
				// We need to fork it... so how many partitions will be needed?
			
				$partitionsNeeded = (int) round( ceil( $listings->count() / $partitionChunkSize ), 0 );
				$routingKey = sprintf("lycan.provider.push.brand.%s", $providerKey);
				foreach(range(0, $partitionsNeeded) as $partIndex => $p){
					$message["partitionIndex"] = $partIndex;
					$message["partitionChunkSize"] = $partitionChunkSize;
					$this->container->get('lycan.rabbit.producer.push_brand')->publish(serialize($message), $routingKey);
				}
				return;
			}
			
			$closure = $manager->getQueuePushListingsClosure();
			
			if(isset($message['partitionIndex'])){
				$jobsInBatch = $listings->count();
				$listings = $listings->slice($message['partitionIndex'] * $partitionChunkSize, $partitionChunkSize);
				$collection = new ArrayCollection($listings);
				$class = $this->em->getClassMetadata( "AppBundle:Listing");
				$persistent = new PersistentCollection($this->em, $class, $collection);
				$offset = $message['partitionIndex'] * $partitionChunkSize;
				$closure( $persistent, (string) $id, $jobsInBatch, $offset );
				
			} else {
				$closure( $listings, $id );
			}
			
			
		} else {
			$provider->setPushInProgress(false);
			$channel->setPushInProgress(false);
			$this->em->persist($provider);
			$this->em->persist($channel);
			$this->em->flush();
			$batchLogger->warning("You have attempted a push to a brand but you do not have any rentals mapped to the brand.", $message );
			
		}
		
				
		$this->em->clear();
		// dump($message);
		
	}
}